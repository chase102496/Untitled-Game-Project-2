[gd_scene load_steps=68 format=3 uid="uid://ct0v1pb5ehqc6"]

[ext_resource type="PackedScene" uid="uid://dtwvcihds5bb3" path="res://scenes/state_chart.tscn" id="2_bj2fs"]
[ext_resource type="PackedScene" uid="uid://b3707fwdhap4h" path="res://status_hud.tscn" id="2_gj4re"]
[ext_resource type="PackedScene" uid="uid://b7x2uimrghas2" path="res://test_junk/debug_3d_text.tscn" id="3_ohwwd"]
[ext_resource type="Texture2D" uid="uid://d4senx3uvusy" path="res://Art/sprites/Axolotl/Spritesheets/Axolotl_Red_Death.png" id="4_yax8f"]
[ext_resource type="Script" path="res://Logic/scripts/animations.gd" id="5_4nqrx"]
[ext_resource type="Texture2D" uid="uid://sqrggdn7ckmy" path="res://Art/sprites/Axolotl/Spritesheets/Axolotl_Red_Floating_Idle.png" id="5_pq05l"]
[ext_resource type="Texture2D" uid="uid://bdjb6koyadhmf" path="res://Art/sprites/Axolotl/Spritesheets/Axolotl_Red_Swimming.png" id="6_i10ad"]
[ext_resource type="AnimationNodeStateMachine" uid="uid://cu5emsrm85m3s" path="res://Art/animations/character_animation_tree_dreamkin.tres" id="8_m4ckd"]
[ext_resource type="Script" path="res://Logic/scripts/character_animation_tree.gd" id="9_wl2do"]
[ext_resource type="PackedScene" uid="uid://c5r06amfsateg" path="res://ui/battle_gui.tscn" id="10_xtrnu"]
[ext_resource type="Script" path="res://Logic/components/component_input_controller_follow.gd" id="12_efiqj"]
[ext_resource type="Script" path="res://Logic/components/component_core_dreamkin.gd" id="13_31q7d"]
[ext_resource type="Script" path="res://Logic/components/component_state_controller_explore.gd" id="14_yw0sx"]
[ext_resource type="Script" path="res://Logic/components/components.gd" id="15_po7pm"]
[ext_resource type="Script" path="res://Logic/components/component_movement_controller.gd" id="20_w2qj1"]
[ext_resource type="Script" path="res://Logic/components/component_animation_controller.gd" id="21_g3svn"]
[ext_resource type="Script" path="res://Logic/components/component_physics.gd" id="22_m25ti"]

[sub_resource type="CapsuleShape3D" id="CapsuleShape3D_dltsc"]

[sub_resource type="AtlasTexture" id="AtlasTexture_1o7u4"]
atlas = ExtResource("4_yax8f")
region = Rect2(0, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_upbka"]
atlas = ExtResource("4_yax8f")
region = Rect2(32, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_tfe5g"]
atlas = ExtResource("4_yax8f")
region = Rect2(64, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_03idb"]
atlas = ExtResource("4_yax8f")
region = Rect2(96, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_ulo3w"]
atlas = ExtResource("4_yax8f")
region = Rect2(0, 32, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_xuser"]
atlas = ExtResource("4_yax8f")
region = Rect2(32, 32, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_4gpr5"]
atlas = ExtResource("4_yax8f")
region = Rect2(64, 32, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_tkiv4"]
atlas = ExtResource("4_yax8f")
region = Rect2(96, 32, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_5ra67"]
atlas = ExtResource("4_yax8f")
region = Rect2(0, 64, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_oicde"]
atlas = ExtResource("4_yax8f")
region = Rect2(32, 64, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_pse75"]
atlas = ExtResource("4_yax8f")
region = Rect2(64, 64, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_0f5gu"]
atlas = ExtResource("4_yax8f")
region = Rect2(96, 64, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_opojh"]
atlas = ExtResource("4_yax8f")
region = Rect2(0, 96, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_5rugh"]
atlas = ExtResource("4_yax8f")
region = Rect2(32, 96, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_ywrnc"]
atlas = ExtResource("4_yax8f")
region = Rect2(64, 96, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_tje2g"]
atlas = ExtResource("4_yax8f")
region = Rect2(96, 96, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_lu6ho"]
atlas = ExtResource("5_pq05l")
region = Rect2(0, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_yac4q"]
atlas = ExtResource("5_pq05l")
region = Rect2(32, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_eicab"]
atlas = ExtResource("5_pq05l")
region = Rect2(64, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_8a1pq"]
atlas = ExtResource("5_pq05l")
region = Rect2(96, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_3xk3r"]
atlas = ExtResource("5_pq05l")
region = Rect2(0, 32, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_y8jcr"]
atlas = ExtResource("5_pq05l")
region = Rect2(32, 32, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_mqtmi"]
atlas = ExtResource("5_pq05l")
region = Rect2(64, 32, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_ehfrl"]
atlas = ExtResource("5_pq05l")
region = Rect2(96, 32, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_ts8e5"]
atlas = ExtResource("6_i10ad")
region = Rect2(0, 0, 32, 33)

[sub_resource type="AtlasTexture" id="AtlasTexture_1c71n"]
atlas = ExtResource("6_i10ad")
region = Rect2(32, 0, 32, 33)

[sub_resource type="AtlasTexture" id="AtlasTexture_yt10v"]
atlas = ExtResource("6_i10ad")
region = Rect2(64, 0, 32, 33)

[sub_resource type="AtlasTexture" id="AtlasTexture_7sbj3"]
atlas = ExtResource("6_i10ad")
region = Rect2(96, 0, 32, 33)

[sub_resource type="AtlasTexture" id="AtlasTexture_tgovw"]
atlas = ExtResource("6_i10ad")
region = Rect2(0, 33, 32, 33)

[sub_resource type="AtlasTexture" id="AtlasTexture_myhmd"]
atlas = ExtResource("6_i10ad")
region = Rect2(32, 33, 32, 33)

[sub_resource type="AtlasTexture" id="AtlasTexture_mf214"]
atlas = ExtResource("6_i10ad")
region = Rect2(64, 33, 32, 33)

[sub_resource type="AtlasTexture" id="AtlasTexture_ovvor"]
atlas = ExtResource("6_i10ad")
region = Rect2(96, 33, 32, 33)

[sub_resource type="AtlasTexture" id="AtlasTexture_q8ovq"]
atlas = ExtResource("6_i10ad")
region = Rect2(0, 66, 32, 33)

[sub_resource type="AtlasTexture" id="AtlasTexture_iqop8"]
atlas = ExtResource("6_i10ad")
region = Rect2(32, 66, 32, 33)

[sub_resource type="AtlasTexture" id="AtlasTexture_53ogs"]
atlas = ExtResource("6_i10ad")
region = Rect2(64, 66, 32, 33)

[sub_resource type="AtlasTexture" id="AtlasTexture_reyy8"]
atlas = ExtResource("6_i10ad")
region = Rect2(96, 66, 32, 33)

[sub_resource type="SpriteFrames" id="SpriteFrames_hyon4"]
animations = [{
"frames": [{
"duration": 1.0,
"texture": SubResource("AtlasTexture_1o7u4")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_upbka")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_tfe5g")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_03idb")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_ulo3w")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_xuser")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_4gpr5")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_tkiv4")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_5ra67")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_oicde")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_pse75")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_0f5gu")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_opojh")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_5rugh")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_ywrnc")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_tje2g")
}],
"loop": true,
"name": &"default_death",
"speed": 5.0
}, {
"frames": [{
"duration": 1.0,
"texture": SubResource("AtlasTexture_lu6ho")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_yac4q")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_eicab")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_8a1pq")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_3xk3r")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_y8jcr")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_mqtmi")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_ehfrl")
}],
"loop": true,
"name": &"default_idle",
"speed": 5.0
}, {
"frames": [{
"duration": 1.0,
"texture": SubResource("AtlasTexture_ts8e5")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_1c71n")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_yt10v")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_7sbj3")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_tgovw")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_myhmd")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_mf214")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_ovvor")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_q8ovq")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_iqop8")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_53ogs")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_reyy8")
}],
"loop": true,
"name": &"default_move",
"speed": 5.0
}]

[sub_resource type="Animation" id="Animation_deov8"]
length = 0.001
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath(".:frame")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [1]
}
tracks/1/type = "value"
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/path = NodePath(".:animation")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [&"default_idle"]
}
tracks/2/type = "value"
tracks/2/imported = false
tracks/2/enabled = true
tracks/2/path = NodePath(".:scale")
tracks/2/interp = 1
tracks/2/loop_wrap = true
tracks/2/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Vector3(4, 4, 4)]
}
tracks/3/type = "value"
tracks/3/imported = false
tracks/3/enabled = true
tracks/3/path = NodePath(".:position")
tracks/3/interp = 1
tracks/3/loop_wrap = true
tracks/3/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Vector3(0, 0, 0)]
}
tracks/4/type = "value"
tracks/4/imported = false
tracks/4/enabled = true
tracks/4/path = NodePath(".:rotation")
tracks/4/interp = 1
tracks/4/loop_wrap = true
tracks/4/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Vector3(0, 0, 0)]
}
tracks/5/type = "value"
tracks/5/imported = false
tracks/5/enabled = true
tracks/5/path = NodePath(".:transparency")
tracks/5/interp = 1
tracks/5/loop_wrap = true
tracks/5/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [0.0]
}

[sub_resource type="Animation" id="Animation_jvi1r"]
resource_name = "default_attack"
length = 1.5
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath(".:frame")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [0]
}
tracks/1/type = "value"
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/path = NodePath(".:position")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/keys = {
"times": PackedFloat32Array(0, 0.5, 0.7, 0.766667, 1, 1.5),
"transitions": PackedFloat32Array(0.341511, 1, 2.54912, 1, 1, 1.03527),
"update": 0,
"values": [Vector3(0, 0, 0), Vector3(-0.183, 0, 0), Vector3(-0.183, 0, 0), Vector3(1, 0, -1), Vector3(1, 0, -1), Vector3(0, 0, 0)]
}
tracks/2/type = "value"
tracks/2/imported = false
tracks/2/enabled = true
tracks/2/path = NodePath(".:scale")
tracks/2/interp = 1
tracks/2/loop_wrap = true
tracks/2/keys = {
"times": PackedFloat32Array(0, 0.7, 0.766667, 1, 1.5),
"transitions": PackedFloat32Array(1, 1, 8.28211, 8.28211, 1),
"update": 0,
"values": [Vector3(4, 4, 4), Vector3(4, 4, 4), Vector3(6, 6, 6), Vector3(5, 5, 5), Vector3(4, 4, 4)]
}
tracks/3/type = "value"
tracks/3/imported = false
tracks/3/enabled = true
tracks/3/path = NodePath(".:animation")
tracks/3/interp = 1
tracks/3/loop_wrap = true
tracks/3/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [&"default_idle"]
}
tracks/4/type = "method"
tracks/4/imported = false
tracks/4/enabled = true
tracks/4/path = NodePath("../character_animation_tree")
tracks/4/interp = 1
tracks/4/loop_wrap = true
tracks/4/keys = {
"times": PackedFloat32Array(0.766667),
"transitions": PackedFloat32Array(1),
"values": [{
"args": [],
"method": &"_on_attack_contact"
}]
}

[sub_resource type="Animation" id="Animation_l8wqm"]
resource_name = "default_death"
length = 0.5
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath(".:animation")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [&"default_death"]
}
tracks/1/type = "value"
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/path = NodePath(".:frame")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/keys = {
"times": PackedFloat32Array(0, 0.0333333, 0.0666667, 0.1, 0.133333, 0.166667, 0.2, 0.233333, 0.266667, 0.3, 0.333333, 0.366667),
"transitions": PackedFloat32Array(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
"update": 1,
"values": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
}

[sub_resource type="Animation" id="Animation_0joem"]
resource_name = "default_hurt"
length = 0.4
step = 0.01
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath(".:animation")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [&"default_death"]
}
tracks/1/type = "value"
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/path = NodePath(".:frame")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [0]
}
tracks/2/type = "value"
tracks/2/imported = false
tracks/2/enabled = true
tracks/2/path = NodePath(".:position")
tracks/2/interp = 1
tracks/2/loop_wrap = true
tracks/2/keys = {
"times": PackedFloat32Array(0, 0.01, 0.03, 0.04, 0.06, 0.07, 0.09, 0.32),
"transitions": PackedFloat32Array(1, 1, 1, 6.27666, 1, 1, 1, 20.393),
"update": 0,
"values": [Vector3(-0.0577791, 0.0823706, 0), Vector3(-0.276845, 0.0823706, 0), Vector3(-0.276845, 0.0823706, 0), Vector3(0.389639, 0.0823706, 0), Vector3(0.389639, 0.0823706, 0), Vector3(-0.276845, 0.0823706, 0), Vector3(-0.276845, 0.0823706, 0), Vector3(0, 0, 0)]
}
tracks/3/type = "value"
tracks/3/imported = false
tracks/3/enabled = true
tracks/3/path = NodePath(".:rotation")
tracks/3/interp = 1
tracks/3/loop_wrap = true
tracks/3/keys = {
"times": PackedFloat32Array(0, 0.01, 0.03, 0.04, 0.06, 0.07, 0.09, 0.32),
"transitions": PackedFloat32Array(1, 1, 1, 6.27667, 1, 1, 1, 7.99999),
"update": 0,
"values": [Vector3(0, 0, 0.0446106), Vector3(0, 0, 0.141232), Vector3(0, 0, 0.141232), Vector3(0, 0, -0.0346971), Vector3(0, 0, -0.0346971), Vector3(0, 0, 0.141232), Vector3(0, 0, 0.141232), Vector3(0, 0, 0)]
}
tracks/4/type = "value"
tracks/4/imported = false
tracks/4/enabled = true
tracks/4/path = NodePath(".:scale")
tracks/4/interp = 1
tracks/4/loop_wrap = true
tracks/4/keys = {
"times": PackedFloat32Array(0, 0.32),
"transitions": PackedFloat32Array(1, 15.455),
"update": 0,
"values": [Vector3(5, 5, 5), Vector3(4, 4, 4)]
}

[sub_resource type="Animation" id="Animation_1fj2r"]
resource_name = "default_idle"
length = 0.2667
loop_mode = 1
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath(".:animation")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [&"default_idle"]
}
tracks/1/type = "value"
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/path = NodePath(".:frame")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/keys = {
"times": PackedFloat32Array(0, 0.0333333, 0.0666667, 0.1, 0.133333, 0.166667, 0.2, 0.233333),
"transitions": PackedFloat32Array(1, 1, 1, 1, 1, 1, 1, 1),
"update": 1,
"values": [0, 1, 2, 3, 4, 5, 6, 7]
}

[sub_resource type="Animation" id="Animation_sxj7a"]
resource_name = "default_walk"
length = 0.4
loop_mode = 1
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath(".:animation")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [&"default_move"]
}
tracks/1/type = "value"
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/path = NodePath(".:frame")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/keys = {
"times": PackedFloat32Array(0, 0.0333333, 0.0666667, 0.1, 0.133333, 0.166667, 0.2, 0.233333, 0.266667, 0.3, 0.333333, 0.366667),
"transitions": PackedFloat32Array(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
"update": 1,
"values": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
}

[sub_resource type="AnimationLibrary" id="AnimationLibrary_7el08"]
_data = {
"RESET": SubResource("Animation_deov8"),
"default_attack": SubResource("Animation_jvi1r"),
"default_death": SubResource("Animation_l8wqm"),
"default_hurt": SubResource("Animation_0joem"),
"default_idle": SubResource("Animation_1fj2r"),
"default_walk": SubResource("Animation_sxj7a")
}

[sub_resource type="GDScript" id="GDScript_5r1s6"]
script/source = "class_name component_state_controller_battle
extends Node

@export var my_component_ability: component_ability

@onready var character_ready : bool = true
@onready var already_applied_end_status : bool = false
@onready var state_chart_memory : String = \"\"

func _ready() -> void:
	
	#Animation
	Events.animation_finished.connect(_on_animation_finished)
	Events.animation_started.connect(_on_animation_started)
	
	#Battle
	Events.turn_start.connect(_on_turn_start)
	Events.battle_entity_hit.connect(_on_battle_entity_hit)
	Events.battle_entity_damaged.connect(_on_battle_entity_damaged)
	#Events.battle_entity_death.connect(_on_battle_entity_death)
	#
	%StateChart/Main/Battle/Waiting.state_entered.connect(_on_state_entered_battle_waiting)
	%StateChart/Main/Battle/Start.state_entered.connect(_on_state_entered_battle_start)
	%StateChart/Main/Battle/Choose.state_entered.connect(_on_state_entered_battle_choose)
	%StateChart/Main/Battle/Skillcheck.state_entered.connect(_on_state_entered_battle_skillcheck)
	%StateChart/Main/Battle/Skillcheck.state_exited.connect(_on_state_exited_battle_skillcheck)
	%StateChart/Main/Battle/Execution.state_entered.connect(_on_state_entered_battle_execution)
	%StateChart/Main/Battle/End.state_entered.connect(_on_state_entered_battle_end)
	%StateChart/Main/Battle/End.state_physics_processing.connect(_on_state_physics_processing_battle_end)

func _physics_process(_delta: float) -> void:
	await owner.ready
	if typeof(owner.state_init_override) == 4: #If it's a string
		owner.state_chart.send_event(owner.state_init_override)
		owner.state_init_override = null

#Battle

func _on_animation_started(anim_name,character) -> void:
	if character == owner:
		var regex = RegEx.new()
		regex.compile(\"(default_)(attack|hurt|death)(_.*)?\")
		if regex.search(anim_name):
			character_ready = false
func _on_animation_finished(anim_name,character) -> void:
	if character == owner:
		var regex = RegEx.new()
		regex.compile(\"(default_)(attack|hurt|death)(_.*)?\")
		var result = regex.search(anim_name)
		if result: #If result is not null
			match result.get_string(2): #match only 2nd group attack|hurt|death
				\"attack\":
					owner.state_chart.send_event(\"on_end\")
				\"hurt\":
					owner.state_chart.send_event(state_chart_memory) #Statecharts has a bug so I bandaided it
				\"death\":
					#Check if we are the last one
					if len(Battle.my_team(owner)) == 1:
						if owner.stats.alignment == Battle.alignment.FOES:
							Events.battle_finished.emit(\"Win\")
						elif owner.stats.alignment == Battle.alignment.FRIENDS:
							Events.battle_finished.emit(\"Lose\")
						else:
							push_error(\"ERROR\")
					#If we aren't just end turn
					elif Battle.active_character == owner:
						Events.turn_end.emit()
					#if we just died and it wasn't our turn, do nothing
					else:
						pass
					Battle.battle_list.pop_at(Battle.battle_list.find(owner,0)) #remove us from queue
					Events.battle_entity_death.emit(owner) #let everyone know we died rip
					owner.queue_free() #deletus da fetus

func _on_battle_entity_damaged(entity : Node, amount : int):
	my_component_ability.current_status_effect.status_event(\"on_host_health_change\",entity,amount)

func _on_turn_start() -> void: #NOT A STATE CHART, JUST FOR VERY BEGINNING OF TURN
	if Battle.active_character == owner:
		already_applied_end_status = false
		owner.state_chart.send_event(\"on_start\")
	else:
		owner.state_chart.send_event(\"on_waiting\")

func _on_state_entered_battle_waiting() -> void:
	character_ready = true
	state_chart_memory = \"on_waiting\"

func _on_state_entered_battle_start() -> void:
	print_debug(\"-----------------------\")
	print_debug(\"Turn Start: \",owner.name)
	
	my_component_ability.skillcheck_difficulty = 1.0 #Reset our skillcheck difficulty
	
	my_component_ability.current_status_effect.status_event(\"on_duration\")
	my_component_ability.current_status_effect.status_event(\"on_start\")
	
	owner.state_chart.send_event(\"on_choose\") 

func _on_state_entered_battle_choose() -> void:
	match owner.stats.glossary:
		\"player\":
			owner.my_battle_gui.state_chart.send_event(\"on_gui_main\")
		\"dreamkin\":
			owner.my_battle_gui.state_chart.send_event(\"on_gui_main\")
		\"enemy\":
			await get_tree().create_timer(0.3).timeout
			my_component_ability.cast_queue = my_component_ability.my_abilities.pick_random() #Pick random move
			
			#TODO Check if queued ability is to be used on allies or enemies before choosing
			#turn this into a script we run with battle list as the entire battle field param, and owner as caster
			#the move will narrow down the list of viable targets based on the input and its move type (myteam, enemies, single target, aoe, self, all)
			#the move will then run a script based on whether we are player/dreamkin or enemy and send gui our target array or randomly select from target array
			#eg if x: do x
			#x is single-target, so we either randomly select 1 person from
			my_component_ability.cast_queue.targets = [Battle.get_team(Battle.alignment.FRIENDS).pick_random()] #Pick random opponent
			owner.state_chart.send_event(\"on_skillcheck\")
		_:
			push_error(\"Not a valid entity for battle: \",owner.name)

func _on_state_entered_battle_skillcheck() -> void:

	match owner.stats.glossary:
		\"enemy\": #weighted random skillcheck
			var skillcheck_result = \"Miss\"
			var skill_rand = randf_range(0,1)/my_component_ability.skillcheck_difficulty #Modify it by skillcheck diff. Higher = smaller num = less good
			if skill_rand >= 0.95:
				skillcheck_result = \"Excellent\"
			elif skill_rand >= 0.8:
				skillcheck_result = \"Great\"
			elif skill_rand >= 0.15:
				skillcheck_result = \"Good\"
			else:
				Events.battle_entity_cast_failed.emit(owner,owner.my_component_ability.cast_queue.targets,owner.my_component_ability.cast_queue) #emit a failed notif
				
			my_component_ability.cast_queue.skillcheck(skillcheck_result)
			owner.state_chart.send_event(\"on_execution\")

func _on_state_exited_battle_skillcheck() -> void:
	match owner.stats.glossary:
		\"player\":
			my_component_ability.cast_queue.skillcheck(owner.my_battle_gui.ui_skillcheck_result) #Modifies our ability based on outcome of skillcheck from ui
		\"dreamkin\":
			my_component_ability.cast_queue.skillcheck(owner.my_battle_gui.ui_skillcheck_result) #Modifies our ability based on outcome of skillcheck from ui
	
func _on_state_entered_battle_execution() -> void:
	if my_component_ability.cast_queue.cast_validate():
		my_component_ability.cast_queue.animation()
	else:
		Events.battle_entity_cast_failed.emit(owner,owner.my_component_ability.cast_queue.target,owner.my_component_ability.cast_queue)
		await get_tree().create_timer(0.5).timeout
		my_component_ability.cast_queue.cast_validate_failed()
		my_component_ability.cast_queue.animation()
		#owner.state_chart.send_event(\"on_end\") #move failed, skip execution

func _on_battle_entity_hit(entity_caster : Node, entity_target : Node, ability : Object) -> void:
	if entity_caster == owner:
		my_component_ability.cast_queue.cast_main()
		my_component_ability.current_status_effect.status_event(\"on_target_hit\")

func _on_state_entered_battle_end() -> void:
	if my_component_ability.current_status_effect and !already_applied_end_status: #yucky cope var
		state_chart_memory = \"on_end\"
		already_applied_end_status = true
		my_component_ability.current_status_effect.status_event(\"on_end\")

func _on_state_physics_processing_battle_end(_delta: float) -> void:
	#End code goes here, then we ready up
	if Battle.check_ready():
		owner.state_chart.send_event(\"on_waiting\")
		Events.turn_end.emit()
	character_ready = true
"

[sub_resource type="GDScript" id="GDScript_51lx8"]
script/source = "class_name component_ability
extends Node

@export var my_component_status : component_status

@onready var cast_queue : Object = null

@onready var current_status_effect : Object = status_manager.new()
#@onready var current_status_effect_2 : Object = status_manager.new()

#We will not assign spells this way, might need to fix tho, hard to set em up without all the vars right in front of you 
@onready var my_abilities : Array = [ability_tackle.new(owner),ability.new(owner),ability.new(owner),ability.new(owner)]# FIXME starts blank
@onready var max_ability_count : int = 4
@onready var skillcheck_difficulty : float = 1.0

func _ready() -> void:
	#current_status_effect_2.NORMAL = status.new(Global.player)
	#current_status_effect_2.status_event(\"test\")
	pass
#------------------------------------------------------------------------------
#DONT use name or owner, already taken
#HACK _init is where you store stuff you'd only need way before battle, like damage, vis cost, etc

# - Functions - #
#Global.status_type.NORMAL, TETHER and SOULBOUND
#NORMAL is just normal status effects, they can overwrite eachother based on priority
#TETHER is an ability based binding, that ties one unit to another in some way
#SOULBOUND is a permanent version of TETHER that persists through battle

class status_manager:
	var NORMAL #Buffs, debuffs, DoT, etc.
	var TETHER #Primarily for Lumia's stitch mechanic
	var SOULBOUND #Primarily for permanent bonds that start at battle initialize
	
	func add(effect : Object):
		#check if they have a partner with the buff NAH
		match effect.category:
			\"NORMAL\":
				if !NORMAL:
					NORMAL = effect
					effect.fx_add()
					print_debug(\"!status added!\")
				elif NORMAL.priority < effect.priority:
					remove(NORMAL)
					NORMAL = effect
					effect.fx_add()
					print_debug(\"!status overwritten!\")
				else:
					print_debug(\"!cannot overwrite current status effect, it's too strong!\")
			\"TETHER\":
				if !TETHER:
					TETHER = effect
					effect.fx_add()
					print_debug(\"!status added!\")
				elif TETHER.priority < effect.priority:
					remove(TETHER)
					TETHER = effect
					effect.fx_add()
					print_debug(\"!status overwritten!\")
				else:
					print_debug(\"!cannot overwrite current status effect, it's too strong!\")
			\"SOULBOUND\":
				if !SOULBOUND:
					SOULBOUND = effect
					effect.fx_add()
					print_debug(\"!status added!\")
				elif SOULBOUND.priority < effect.priority:
					remove(SOULBOUND)
					SOULBOUND = effect
					effect.fx_add()
					print_debug(\"!status overwritten!\")
				else:
					print_debug(\"!cannot overwrite current status effect, it's too strong!\")
			_:
				push_error(\"COULD NOT ADD \",effect,\" TO \",effect.category)
	
	func remove(effect : Object):
		match effect.category:
			\"NORMAL\":
				if NORMAL:
					print_debug(\"!status removed!\")
					NORMAL.fx_remove()
					NORMAL = null
				else:
					print_debug(\"!no status effect to remove!\")
			\"TETHER\":
				if TETHER:
					print_debug(\"!status removed!\")
					TETHER.fx_remove()
					TETHER = null
				else:
					print_debug(\"!no status effect to remove!\")
			\"SOULBOUND\":
				if SOULBOUND:
					print_debug(\"!status removed!\")
					SOULBOUND.fx_remove()
					SOULBOUND = null
				else:
					print_debug(\"!no status effect to remove!\")
			_:
				push_error(\"COULD NOT REMOVE \",effect,\" TO \",effect.category)

	func status_event(event : String, arg1 = null, arg2 = null, arg3 = null):
		if NORMAL and NORMAL.has_method(event):
			if arg3:
				Callable(NORMAL,event).call(arg1,arg2,arg3)
			elif arg2:
				Callable(NORMAL,event).call(arg1,arg2)
			elif arg1:
				Callable(NORMAL,event).call(arg1)
			else:
				Callable(NORMAL,event).call()
		if TETHER and TETHER.has_method(event):
			if arg3:
				Callable(TETHER,event).call(arg1,arg2,arg3)
			elif arg2:
				Callable(TETHER,event).call(arg1,arg2)
			elif arg1:
				Callable(TETHER,event).call(arg1)
			else:
				Callable(TETHER,event).call()
		if SOULBOUND and SOULBOUND.has_method(event):
			if arg3:
				Callable(SOULBOUND,event).call(arg1,arg2,arg3)
			elif arg2:
				Callable(SOULBOUND,event).call(arg1,arg2)
			elif arg1:
				Callable(SOULBOUND,event).call(arg1)
			else:
				Callable(SOULBOUND,event).call()

#need to make a tether class and then subclasses based on what to do with the tether
#one called tether_heart which shares damage between the two
#one called tether_undying which makes the target check if its partner is dead before truly dying, and if not, \"revive\" to full health
#	should play death animation and stay in it until the next start() and then revive and reset to full
#

# - Status Effects - #
class status:
	var host : Node #The owner of the status effect. Who to apply it to
	var category : String = \"NORMAL\"
	var duration : int #How many turns it lasts
	var title : String = \"---\"
	var fx : Node #Visual fx
	var priority : int = 0 #Whether a buff can overwrite it. Higher means it can
	
	func _init(host : Node) -> void:
		self.host = host
	
	func test():
		print(\"SUCCESS\")
	
	func on_duration():
		if duration > 0:
			duration -= 1
		else:
			on_remove()
	
	func on_start(): #runs on start of turn
		pass
	
	func on_skillcheck(): #runs right before skillcheck
		pass
	
	func on_target_hit(): #runs right after we attack someone
		pass
	
	func on_host_health_change(entity,amount): #runs when the host of the status effect's health changes
		pass
	
	func on_end(): #runs on end of turn
		pass
	
	func on_remove(): #runs when status effect expires
		print_debug(title,\" wore off for \",host.name,\"!\")
		host.my_component_ability.current_status_effect.remove(self)
	
	func fx_add():
		pass
	
	func fx_remove():
		pass
# ---

# NORMAL
class status_fear:
	extends status
	
	func _init(host : Node,duration : int) -> void:
		self.host = host
		self.duration = duration
		self.title = \"Fear\"
		self.priority = 1
	
	func on_start():
		host.my_component_ability.skillcheck_difficulty += 1
	
	func fx_add():
		fx = Glossary.particle.fear.instantiate()
		host.animations.sprite.add_child(fx)
		fx.global_position = host.animations.sprite.global_position
	
	func fx_remove():
		fx.queue_free()
		fx = null

class status_burn:
	extends status
	
	var damage : int
	
	func _init(host : Node,duration : int,damage : int) -> void:
		self.host = host
		self.duration = duration
		self.damage = damage
		self.title = \"Burn\"
	
	func on_end():
		host.my_component_health.damage(damage)
	
	func fx_add():
		fx = Glossary.particle.burn.instantiate()
		host.animations.sprite.add_child(fx)
		fx.global_position = host.animations.sprite.global_position
	
	func fx_remove():
		fx.queue_free()
		fx = null

# TETHER

class status_tether_heart:
	extends status
	
	var partners : Array
	#var fx2 : Node
	
	func _init(host : Node,partners : Array,duration : int) -> void:
		self.host = host #who is the initial target of the stitch
		self.partners = partners #who is paired to the host
		self.duration = duration
		category = \"TETHER\"
		title = \"Heartstitch\"
	
	func on_host_health_change(entity,amount): #the bread n butta of heartstitch
		if entity == host and len(partners) > 1: #if person hurt was our host, and partners aint all ded
			for i in len(partners):
				if partners[i] != host:
					partners[i].my_component_health.damage(amount,true)
					print_debug(partners[i].name,\" took \",amount,\" points of mirror damage!\")
	
	func fx_add():
		fx = Glossary.ui.heartstitch.instantiate()
		host.status_hud.grid.add_child(fx)
	
	func fx_remove():
		fx.queue_free()
		fx = null

# - Abilities - #
class ability:

	var skillcheck_modifier : int = 1
	var caster : Node
	var target : Node = null #TODO remove
	var targets : Array = []
	#Change this to a function (Callable type) that returns a list of whatever you want. Make the function in Battle
	var target_type : String = Battle.target_type.EVERYONE #Who we can target on the field
	var target_selector : String = Battle.target_selector.SINGLE #How many targets we select
	
	var title : String = \"---\"
	var type : Dictionary = Battle.type.EMPTY
	
	var damage : int = 0
	var vis_cost : int = 0
	
	func _init(caster : Node) -> void:
		self.caster = caster
	
	func select_validate(): #run validations, check vis, health, etc
		var result = false #default so we cannot use this move
		return result
	
	func select_validate_failed():
		print_debug(\"Can't do that\")
		#You can execute code here, run a Dialogic event to show them they can't use that, etc
		pass
	
	func skillcheck(result):
		if result == \"Miss\":
			skillcheck_modifier = 0
		elif result == \"Good\":
			skillcheck_modifier = 1
		elif result == \"Great\":
			skillcheck_modifier = 2
		elif result == \"Excellent\":
			skillcheck_modifier = 3
		else:
			skillcheck_modifier = 1
		
		print_debug(\"Result of skillcheck is \",result)
	
	func cast_validate():
		if skillcheck_modifier > 0:
			return true
		else:
			return false
			
	func cast_validate_failed():
		print_debug(\"It failed!\")
	
	func cast_main(): #Main function, calls on hit
		pass
	
	func animation():
		caster.animations.tree.get(\"parameters/playback\").travel(\"default_attack\")
	
	#Put status effect in here, and when we cast, we add our spell to their status_effects array based on conditions (only one status at a time, if it's used we send a message saying they're immune)
	#They run their normal course, but are \"infected\" with our functions. Now the empty method calls 
	#when they were healthy will reference any calls in our spell's vocab and we don't have to do anything on character-side
	#E.g. Poison spell
	#Has function status_effect_on_start
# ---

class ability_template_default: #Standard ability with vis cost and skillcheck
	extends ability
	
	func _init() -> void:
		target_type = Battle.target_type.OPPONENTS
	
	func select_validate():
		if caster.my_component_vis.vis >= vis_cost:
			return true
		else:
			print_debug(\"Not enough Vis!\")
			return false
	
	func skillcheck(result): #TODO make categories of skillchecks to extend from
		if result == \"Miss\":
			skillcheck_modifier = 0
		elif result == \"Good\":
			skillcheck_modifier = 1
		elif result == \"Great\":
			skillcheck_modifier = 2
		elif result == \"Excellent\":
			skillcheck_modifier = 3
		else:
			skillcheck_modifier = 1

class ability_spook:
	extends ability_template_default
	
	func _init(caster : Node) -> void:
		self.caster = caster
		type = Battle.type.VOID
		title = \"Spook\"
		vis_cost = 2
		damage = 1

	func cast_main():
		if skillcheck_modifier > 0:
			print_debug(\"It was successful!\")
			caster.my_component_vis.siphon(vis_cost)
			for i in len(targets):
				print_debug(caster.name, \" tried to spook \", targets[i].name,\"!\")
				targets[i].my_component_health.damage(damage) #Flat damage
				targets[i].my_component_ability.current_status_effect.add(status_fear.new(targets[i],skillcheck_modifier*2)) #duration is 2x of modifier
		else:
			cast_validate_failed()
			
	func animation():
		caster.animations.tree.get(\"parameters/playback\").travel(\"default_attack_spook\")

class ability_solar_flare:
	extends ability_template_default
	
	func _init(caster : Node) -> void:
		self.caster = caster
		type = Battle.type.NOVA
		title = \"Solar Flare\"
		vis_cost = 2
		damage = 1
	
	func cast_main():
		if skillcheck_modifier > 0:
			caster.my_component_vis.siphon(vis_cost)
			for i in len(targets):
				print_debug(caster.name, \" ignited \", targets[i].name,\"!\")
				targets[i].my_component_health.damage(damage) #Flat damage
				targets[i].my_component_ability.current_status_effect.add(status_burn.new(targets[i],skillcheck_modifier*2,1))
		else:
			cast_validate_failed()
			
	func animation():
		caster.animations.tree.get(\"parameters/playback\").travel(\"default_attack\") #TODO make solar flare animation or FX

class ability_tackle:
	extends ability_template_default
	
	func _init(caster : Node) -> void:
		self.caster = caster
		damage = 1
		type = Battle.type.NEUTRAL
		target_type = Battle.target_type.OPPONENTS
		title = \"Tackle\"
	
	func cast_main():
		if skillcheck_modifier > 0:
			caster.my_component_vis.siphon(vis_cost)
			for i in len(targets):
				print_debug(caster.name, \" Tackled \", targets[i].name,\"!\")
				print_debug(\"It did \", round(skillcheck_modifier*damage), \" damage!\")
				targets[i].my_component_health.damage(skillcheck_modifier*damage)
		else:
			cast_validate_failed()

class ability_heart_stitch:
	extends ability_template_default
	
	var old_targets : Array = []

	func _init(caster : Node) -> void:
		self.caster = caster
		target_selector = Battle.target_selector.SINGLE_RIGHT
		type = Battle.type.VOID
		title = \"Heartstitch\"
		vis_cost = 2
		damage = 1
	
	func cast_main():
		print_debug(caster.name, \" tried to stitch \", targets[0].name,\"!\")
		if skillcheck_modifier > 0:
			print_debug(\"It was successful!\")
			caster.my_component_vis.siphon(vis_cost)
			for i in len(targets):
				targets[i].my_component_health.damage(damage) #Flat damage
				targets[i].my_component_ability.current_status_effect.add(status_tether_heart.new(targets[i],targets,skillcheck_modifier*1))
			for i in len(old_targets):
				if old_targets[i]:
					if old_targets[i].my_component_ability.current_status_effect.TETHER.title == title: #If we find they still have our old buff
						old_targets[i].my_component_ability.current_status_effect.remove(old_targets[i].my_component_ability.current_status_effect.TETHER) #remove
			old_targets = targets
		else:
			print_debug(\"It failed!\")
			
	func animation():
		caster.animations.tree.get(\"parameters/playback\").travel(\"default_attack\") #TODO
"

[sub_resource type="GDScript" id="GDScript_0l2u8"]
script/source = "class_name component_status
extends Node

@export var my_component_ability : component_ability
"

[sub_resource type="GDScript" id="GDScript_mvmr5"]
script/source = "class_name component_health
extends Node

@export var max_health : int = 6
var health : int

func _ready() -> void:
	health = max_health

func damage(amt, mirror_damage : bool = false, type : Dictionary = Battle.type.NEUTRAL,):
	if amt != 0:
		if !mirror_damage: #To protect recursive when using heartstitch
			Events.battle_entity_damaged.emit(owner,amt)
		match type:
			Battle.type.VOID:
				#Send signal out that we recieved damage, who we are, and how much
				print_debug(health,\" HP -> \",health - amt,\" HP\")
				health -= amt
				
				if health <= 0:
					owner.state_chart.send_event(\"on_death\")
				else:
					owner.state_chart.send_event(\"on_hurt\")
			Battle.type.NEUTRAL:
				print_debug(health,\" HP -> \",health - amt,\" HP\")
				health -= amt
				
				if health <= 0:
					owner.state_chart.send_event(\"on_death\")
				else:
					owner.state_chart.send_event(\"on_hurt\")
			Battle.type.NOVA:
				print_debug(health,\" HP -> \",health - amt,\" HP\")
				health -= amt
				
				if health <= 0:
					owner.state_chart.send_event(\"on_death\")
				else:
					owner.state_chart.send_event(\"on_hurt\")
"

[sub_resource type="GDScript" id="GDScript_vvwdn"]
script/source = "class_name component_vis
extends Node

@export var max_vis : int = 6
var vis : int

func _ready() -> void:
	vis = max_vis

func siphon(amt): #removes vis
	print_debug(vis,\" MP -> \",vis - amt,\" MP\")
	vis -= amt
"

[node name="Dreamkin" type="CharacterBody3D"]
physics_interpolation_mode = 1
transform = Transform3D(0.5, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 0, 0, 0)
collision_layer = 2
collision_mask = 2

[node name="Status_HUD" parent="." instance=ExtResource("2_gj4re")]
unique_name_in_owner = true

[node name="StateChart" parent="." instance=ExtResource("2_bj2fs")]
unique_name_in_owner = true

[node name="DEBUG_3D_TEXT" parent="." node_paths=PackedStringArray("my_component_state_controller_battle", "my_component_health", "my_component_vis") instance=ExtResource("3_ohwwd")]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0.0184311, -0.243187, -0.270939)
my_component_state_controller_battle = NodePath("../Components/component_state_controller_battle")
my_component_health = NodePath("../Components/component_health")
my_component_vis = NodePath("../Components/component_vis")

[node name="CollisionShape3D" type="CollisionShape3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0.101925, 0.0287893, 0.00621723)
shape = SubResource("CapsuleShape3D_dltsc")

[node name="Animations" type="Node3D" parent="."]
unique_name_in_owner = true
script = ExtResource("5_4nqrx")

[node name="character_animation_sprite" type="AnimatedSprite3D" parent="Animations"]
transform = Transform3D(4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0)
flip_h = true
shaded = true
alpha_cut = 2
texture_filter = 0
sprite_frames = SubResource("SpriteFrames_hyon4")
animation = &"default_idle"
frame = 1

[node name="character_animation_player" type="AnimationPlayer" parent="Animations"]
root_node = NodePath("../character_animation_sprite")
libraries = {
"": SubResource("AnimationLibrary_7el08")
}

[node name="character_animation_tree" type="AnimationTree" parent="Animations"]
active = false
root_node = NodePath("../character_animation_sprite")
tree_root = ExtResource("8_m4ckd")
anim_player = NodePath("../character_animation_player")
parameters/Death/TimeScale/scale = 0.4
parameters/Hurt/TimeScale/scale = 1.0
parameters/Idle/TimeScale/scale = 0.2
parameters/Walk/TimeScale/scale = 0.5
script = ExtResource("9_wl2do")

[node name="Battle_GUI" parent="." instance=ExtResource("10_xtrnu")]
unique_name_in_owner = true

[node name="Components" type="Node" parent="."]
unique_name_in_owner = true
script = ExtResource("15_po7pm")

[node name="component_core_dreamkin" type="Node" parent="Components"]
script = ExtResource("13_31q7d")

[node name="component_state_controller_battle" type="Node" parent="Components" node_paths=PackedStringArray("my_component_ability")]
script = SubResource("GDScript_5r1s6")
my_component_ability = NodePath("../component_ability")

[node name="component_state_controller_explore" type="Node" parent="Components" node_paths=PackedStringArray("my_component_input_controller")]
script = ExtResource("14_yw0sx")
my_component_input_controller = NodePath("../component_input_controller_follow")

[node name="component_ability" type="Node" parent="Components" node_paths=PackedStringArray("my_component_status")]
script = SubResource("GDScript_51lx8")
my_component_status = NodePath("../component_status")

[node name="component_status" type="Node" parent="Components" node_paths=PackedStringArray("my_component_ability")]
script = SubResource("GDScript_0l2u8")
my_component_ability = NodePath("../component_ability")

[node name="component_health" type="Node" parent="Components"]
script = SubResource("GDScript_mvmr5")

[node name="component_vis" type="Node" parent="Components"]
script = SubResource("GDScript_vvwdn")

[node name="component_movement_controller" type="Node" parent="Components" node_paths=PackedStringArray("my_component_input_controller")]
script = ExtResource("20_w2qj1")
my_component_input_controller = NodePath("../component_input_controller_follow")
movespeed = 10

[node name="component_input_controller_follow" type="Node" parent="Components" node_paths=PackedStringArray("my_component_movement_controller")]
script = ExtResource("12_efiqj")
my_component_movement_controller = NodePath("../component_movement_controller")

[node name="component_animation_controller" type="Node" parent="Components" node_paths=PackedStringArray("my_component_input_controller")]
script = ExtResource("21_g3svn")
my_component_input_controller = NodePath("../component_input_controller_follow")

[node name="component_physics" type="Node" parent="Components"]
script = ExtResource("22_m25ti")

[connection signal="animation_finished" from="Animations/character_animation_tree" to="Animations/character_animation_tree" method="_on_animation_finished"]
[connection signal="animation_started" from="Animations/character_animation_tree" to="Animations/character_animation_tree" method="_on_animation_started"]
