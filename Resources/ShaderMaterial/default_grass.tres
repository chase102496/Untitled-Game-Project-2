[gd_resource type="ShaderMaterial" load_steps=4 format=3 uid="uid://dcxon1inotuhr"]

[ext_resource type="Texture2D" uid="uid://cqpfx4uio724h" path="res://Art/textures/oleekconder/T_Grass6_Color.png" id="1_sfa1u"]

[sub_resource type="Shader" id="Shader_3cmx7"]
code = "shader_type spatial;
render_mode blend_mix, depth_draw_opaque, cull_back, diffuse_burley, specular_schlick_ggx;

// Texture Settings
uniform vec4 albedo : source_color;


// Material Properties
uniform float roughness : hint_range(0.0, 1.0);
uniform float metallic : hint_range(0.0, 1.0);
uniform float specular : hint_range(0.0, 1.0);

// Triplanar Mapping Settings
uniform bool use_world_triplanar = false;
uniform float uv1_blend_sharpness : hint_range(0.0, 150.0, 0.001);
uniform vec3 uv1_scale;
uniform vec3 uv1_offset;

// Grayscale and Recoloring Settings
uniform sampler2D texture_albedo : source_color, filter_linear_mipmap, repeat_enable;
uniform vec3 replacement_color : source_color = vec3(1.0, 1.0, 1.0); // Replacement tint color
uniform float grayscale_factor : hint_range(0.0, 1.0) = 0.0; // 0 = original color, 1 = full grayscale
uniform float luminosity_factor : hint_range(0.0, 2.0) = 1.0; // Adjusts brightness
uniform float recolor_factor : hint_range(0.0, 2.0) = 1.0; // 0 = grayscale, 1 = full recolor, >1 = oversaturation
uniform bool use_gradient = false; // Toggle gradient mapping*
uniform sampler2D gradient_texture : hint_default_white; // Gradient texture for mapping grayscale

// Varyings for Triplanar Mapping
varying vec3 uv1_triplanar_pos;
varying vec3 uv1_power_normal;

void vertex() {
    vec3 normal = MODEL_NORMAL_MATRIX * NORMAL;

    // Calculate tangent and binormal
    TANGENT = vec3(0.0, 0.0, -1.0) * abs(normal.x);
    TANGENT += vec3(1.0, 0.0, 0.0) * abs(normal.y);
    TANGENT += vec3(1.0, 0.0, 0.0) * abs(normal.z);
    TANGENT = inverse(MODEL_NORMAL_MATRIX) * normalize(TANGENT);

    BINORMAL = vec3(0.0, 1.0, 0.0) * abs(normal.x);
    BINORMAL += vec3(0.0, 0.0, -1.0) * abs(normal.y);
    BINORMAL += vec3(0.0, 1.0, 0.0) * abs(normal.z);
    BINORMAL = inverse(MODEL_NORMAL_MATRIX) * normalize(BINORMAL);

    // Conditional triplanar calculation
    if (use_world_triplanar) {
        uv1_power_normal = pow(abs(normal), vec3(uv1_blend_sharpness));
        uv1_triplanar_pos = (MODEL_MATRIX * vec4(VERTEX, 1.0)).xyz * uv1_scale + uv1_offset;
        uv1_power_normal /= dot(uv1_power_normal, vec3(1.0));
        uv1_triplanar_pos *= vec3(1.0, -1.0, 1.0);
    } else {
        uv1_triplanar_pos = vec3(VERTEX.xy * uv1_scale.xy + uv1_offset.xy, 0.0);
        uv1_power_normal = vec3(0.0, 0.0, 1.0); // Default direction for local mapping
    }
}

vec4 triplanar_texture(sampler2D p_sampler, vec3 p_weights, vec3 p_triplanar_pos) {
    vec4 samp = vec4(0.0);
    samp += texture(p_sampler, p_triplanar_pos.xy) * p_weights.z;
    samp += texture(p_sampler, p_triplanar_pos.xz) * p_weights.y;
    samp += texture(p_sampler, p_triplanar_pos.zy * vec2(-1.0, 1.0)) * p_weights.x;
    return samp;
}

void fragment() {
    // Choose the texture mapping method
    vec4 albedo_tex;
    if (use_world_triplanar) {
        albedo_tex = triplanar_texture(texture_albedo, uv1_power_normal, uv1_triplanar_pos);
    } else {
        albedo_tex = texture(texture_albedo, UV);
    }

    // Calculate the original color
    vec3 original_color = albedo.rgb * albedo_tex.rgb;

    // Grayscale calculations
    float grayscale = 0.299 * original_color.r + 0.587 * original_color.g + 0.114 * original_color.b;

    // Step 1: Blend original color into grayscale based on grayscale_factor
    vec3 grayscaled_color = mix(original_color, vec3(grayscale), grayscale_factor);

    // Step 2: Use gradient or replacement color for recoloring
    vec3 recolor;
    if (use_gradient) {
        // Smooth gradient mapping
        float gradient_step = 1.0 / float(textureSize(gradient_texture, 0).x);
        float step_start = floor(grayscale / gradient_step) * gradient_step;
        float step_end = step_start + gradient_step;
        float t = (grayscale - step_start) / gradient_step;

        vec3 color_start = texture(gradient_texture, vec2(step_start, 0.5)).rgb;
        vec3 color_end = texture(gradient_texture, vec2(step_end, 0.5)).rgb;

        // Blend with smoothing
        recolor = mix(color_start, color_end, smoothstep(0.0, 1.0, t));
    } else {
        recolor = replacement_color * grayscale;
    }

    // Step 3: Blend grayscaled color into recolored version based on recolor_factor
    float recolor_blend = min(recolor_factor, 1.0); // Limit blend factor to 1.0
    vec3 recolored_color = mix(grayscaled_color, recolor, recolor_blend);

    // Step 4: Gradually oversaturate if recolor_factor > 1.0
    if (recolor_factor > 1.0) {
        float oversaturation = recolor_factor - 1.0;
        recolored_color = mix(recolored_color, recolored_color * 1.5, oversaturation); // Controlled oversaturation
    }

    // Adjust brightness
    vec3 final_color = recolored_color * luminosity_factor;

    // Set final color
    ALBEDO = final_color;
}
"

[sub_resource type="GradientTexture1D" id="GradientTexture1D_3ucr3"]
width = 16

[resource]
resource_local_to_scene = true
render_priority = 0
shader = SubResource("Shader_3cmx7")
shader_parameter/albedo = Color(1, 1, 1, 1)
shader_parameter/roughness = 1.0
shader_parameter/metallic = 0.0
shader_parameter/specular = 0.5
shader_parameter/use_world_triplanar = true
shader_parameter/uv1_blend_sharpness = 2.0
shader_parameter/uv1_scale = Vector3(0.3, 0.3, 0.3)
shader_parameter/uv1_offset = Vector3(0, 0, 0)
shader_parameter/replacement_color = Color(0.486275, 0.454902, 0.74902, 1)
shader_parameter/grayscale_factor = 0.0
shader_parameter/luminosity_factor = 1.0
shader_parameter/recolor_factor = 1.0
shader_parameter/use_gradient = false
shader_parameter/texture_albedo = ExtResource("1_sfa1u")
shader_parameter/gradient_texture = SubResource("GradientTexture1D_3ucr3")
